/*******************************************************************************
 * Copyright (C) 2016 Michael Johnson
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>
 *******************************************************************************/
package pso.implementation.random;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import pso.async.implementation.boundary.BoundaryHandler;
import pso.implementation.optimization.SampleOptimizer;
import pso.implementation.search.SearchDomain;

import log.ApplicationLogger;

/**
 * This class is used to generate the seeds for the RNGs in the
 * {@link RandomStreamer} class.
 * 
 * The {@link SeedSet} is given a simulation number, the number of robots per
 * simulation, and the number of dimensions in the fitness function and it
 * calculates seeds which will ensure that the sequences of numbers generated by
 * the RNGs will be statistically independent and have little to no correlation
 * 
 * @author Mike Johnson
 * 
 */
public class SeedSet
{
	/**
	 * Logger reference
	 */
	private ApplicationLogger	log						= ApplicationLogger
																.getInstance();
	
	/**
	 * The seed used by the RNG that breaks ties in fitness values between two
	 * samples, for the global {@link SampleOptimizer}
	 */
	protected int				globalTieSeed			= -1;
	
	/**
	 * The seed used by the RNG that is used by the Random Back Boundary
	 * Technique used by the {@link BoundaryHandler}
	 */
	protected int				randBackSeed			= -1;
	
	/**
	 * The seed used by the RNG that is used to remove duplicate locations
	 */
	protected int				duplicateSeed			= -1;
	
	/**
	 * A {@link List} of the seeds used by the RNGs that break ties in fitness
	 * values between two samples, for each of the local {@link SampleOptimizer}
	 */
	protected List<Integer>		localTieSeeds			= null;
	
	/**
	 * A {@link List} of the seeds used by the RNGs which will generate a random
	 * vector in the {@link SearchDomain} of the Fitness Function. These RNGs
	 * will be the primary source of random vectors in the {@link SearchDomain}.
	 */
	protected List<Integer>		primaryFitnessSeeds		= null;
	
	/**
	 * A {@link List} of the seeds used by the RNGs which will generate a random
	 * vector in the {@link SearchDomain} of the Fitness Function. These RNGs
	 * will be the secondary source of random vectors in the
	 * {@link SearchDomain}.
	 */
	protected List<Integer>		secondaryFitnessSeeds	= null;
	
	/**
	 * Initialize the seed set and calculate the seeds
	 * 
	 * @param simulationNumber
	 * @param numRobots
	 * @param numDimensions
	 */
	public SeedSet (int simulationNumber, int numRobots, int numDimensions)
	{
		// initialize the lists
		localTieSeeds = new ArrayList<Integer>(numRobots);
		primaryFitnessSeeds = new ArrayList<Integer>(numDimensions);
		secondaryFitnessSeeds = new ArrayList<Integer>(numDimensions);
		
		calculateSeeds(simulationNumber, numRobots, numDimensions);
	}
	
	/**
	 * Calculates the seeds using SHA-256
	 * 
	 * @param simulationNumber
	 * @param numRobots
	 * @param numDimensions
	 */
	protected void calculateSeeds (int simulationNumber, int numRobots,
			int numDimensions)
	{
		// to allow the unit tester to get full coverage
		calculateSeeds(simulationNumber, numRobots, numDimensions, "SHA-256");
	}
	
	/**
	 * Initializes the {@link MessageDigest} which will be used to calculate a
	 * hash function
	 * 
	 * @param digest
	 * @return
	 */
	protected MessageDigest initializeHasher (String digest)
	{
		MessageDigest md = null;
		try
		{
			md = MessageDigest.getInstance(digest);
		}
		catch (NoSuchAlgorithmException e)
		{
			log.logException(e);
		}
		
		return md;
	}
	
	/**
	 * Calculates the hash of a given seed, using the specified
	 * {@link MessageDigest}
	 * 
	 * @param seed
	 * @param md
	 * @return
	 */
	protected Integer calculateHash (int seed, MessageDigest md)
	{
		// create our seed
		ByteBuffer bb = ByteBuffer.allocate(4);
		bb.putInt(seed);
		
		// calculate the 32 byte hash
		byte[] hashInBytes = md.digest(bb.array());
		
		// gets the last 4 bytes
		Integer hash = ByteBuffer.wrap(hashInBytes).getInt(28);
		
		// debug print the result
		ByteBuffer bbDbg = ByteBuffer.allocate(4);
		bbDbg.putInt(hash);
		
		// log.logDebug("Hash Size: " + hashInBytes.length);
		log.logDebug("Hash in bytes: %s", Arrays.toString(hashInBytes));
		log.logDebug("Hash Int bytes: %s", Arrays.toString(bbDbg.array()));
		log.logDebug("Hash: %d", hash);
		
		return hash;
	}
	
	/**
	 * Calculates the seeds using a specified hashing algorithm
	 * 
	 * @param simulationNumber
	 * @param numRobots
	 * @param numDimensions
	 * @param digest
	 */
	protected void calculateSeeds (int simulationNumber, int numRobots,
			int numDimensions, String digest)
	{
		// initialize the hash generator
		MessageDigest md = initializeHasher(digest);
		
		// calculate the total number of seeds for this simulation
		final int totalSimulationSeeds =
				1 + 1 + 1 + numRobots + numDimensions + numDimensions;
		final int initialSeed = simulationNumber * totalSimulationSeeds;
		
		log.logDebug("Simulation Number: %d", simulationNumber);
		log.logDebug("Initial Seed: " + initialSeed);
		
		// calculate the non-list seeds
		
		int count = initialSeed;
		globalTieSeed = calculateHash(count, md);
		randBackSeed = calculateHash(count++ , md);
		duplicateSeed = calculateHash(count++ , md);
		
		// calculate the Lists of seeds
		
		for (int i = 0; i < numRobots; i++ )
		{
			localTieSeeds.add(calculateHash(count++ , md));
		}
		
		for (int i = 0; i < numDimensions; i++ )
		{
			primaryFitnessSeeds.add(calculateHash(count++ , md));
		}
		
		for (int i = 0; i < numDimensions; i++ )
		{
			secondaryFitnessSeeds.add(calculateHash(count++ , md));
		}
		
		// minus 1 because indexed from 0
		if (count != (initialSeed + totalSimulationSeeds - 1)) { throw new IllegalStateException(
				"Seeds were not properly initialized"); }
	}
	
	/**
	 * @return the globalTieSeed
	 */
	public int getGlobalTieSeed ()
	{
		return globalTieSeed;
	}
	
	/**
	 * @param globalTieSeed the globalTieSeed to set
	 */
	public void setGlobalTieSeed (int globalTieSeed)
	{
		this.globalTieSeed = globalTieSeed;
	}
	
	/**
	 * @return the randBackSeed
	 */
	public int getRandBackSeed ()
	{
		return randBackSeed;
	}
	
	/**
	 * @param randBackSeed the randBackSeed to set
	 */
	public void setRandBackSeed (int randBackSeed)
	{
		this.randBackSeed = randBackSeed;
	}
	
	/**
	 * @return the duplicateSeed
	 */
	public int getDuplicateSeed ()
	{
		return duplicateSeed;
	}
	
	/**
	 * @param duplicateSeed the duplicateSeed to set
	 */
	public void setDuplicateSeed (int duplicateSeed)
	{
		this.duplicateSeed = duplicateSeed;
	}
	
	/**
	 * @return the localTieSeeds
	 */
	public List<Integer> getLocalTieSeeds ()
	{
		return localTieSeeds;
	}
	
	/**
	 * @param localTieSeeds the localTieSeeds to set
	 */
	public void setLocalTieSeeds (List<Integer> localTieSeeds)
	{
		this.localTieSeeds = localTieSeeds;
	}
	
	/**
	 * @return the primaryFitnessSeeds
	 */
	public List<Integer> getPrimaryFitnessSeeds ()
	{
		return primaryFitnessSeeds;
	}
	
	/**
	 * @param primaryFitnessSeeds the primaryFitnessSeeds to set
	 */
	public void setPrimaryFitnessSeeds (List<Integer> primaryFitnessSeeds)
	{
		this.primaryFitnessSeeds = primaryFitnessSeeds;
	}
	
	/**
	 * @return the secondaryFitnessSeeds
	 */
	public List<Integer> getSecondaryFitnessSeeds ()
	{
		return secondaryFitnessSeeds;
	}
	
	/**
	 * @param secondaryFitnessSeeds the secondaryFitnessSeeds to set
	 */
	public void setSecondaryFitnessSeeds (List<Integer> secondaryFitnessSeeds)
	{
		this.secondaryFitnessSeeds = secondaryFitnessSeeds;
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode ()
	{
		final int prime = 31;
		int result = 1;
		result = prime * result + duplicateSeed;
		result = prime * result + globalTieSeed;
		result =
				prime
						* result
						+ ( (localTieSeeds == null) ? 0 : localTieSeeds
								.hashCode());
		result =
				prime
						* result
						+ ( (primaryFitnessSeeds == null) ? 0
								: primaryFitnessSeeds.hashCode());
		result = prime * result + randBackSeed;
		result =
				prime
						* result
						+ ( (secondaryFitnessSeeds == null) ? 0
								: secondaryFitnessSeeds.hashCode());
		return result;
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals (Object obj)
	{
		if (this == obj) return true;
		if (obj == null) return false;
		if (getClass() != obj.getClass()) return false;
		SeedSet other = (SeedSet) obj;
		if (duplicateSeed != other.duplicateSeed) return false;
		if (globalTieSeed != other.globalTieSeed) return false;
		if (localTieSeeds == null)
		{
			if (other.localTieSeeds != null) return false;
		}
		else if (!localTieSeeds.equals(other.localTieSeeds)) return false;
		if (primaryFitnessSeeds == null)
		{
			if (other.primaryFitnessSeeds != null) return false;
		}
		else if (!primaryFitnessSeeds.equals(other.primaryFitnessSeeds)) return false;
		if (randBackSeed != other.randBackSeed) return false;
		if (secondaryFitnessSeeds == null)
		{
			if (other.secondaryFitnessSeeds != null) return false;
		}
		else if (!secondaryFitnessSeeds.equals(other.secondaryFitnessSeeds)) return false;
		return true;
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString ()
	{
		return String
				.format("SeedSet [globalTieSeed=%s, randBackSeed=%s, duplicateSeed=%s, localTieSeeds=%s, primaryFitnessSeeds=%s, secondaryFitnessSeeds=%s]",
						globalTieSeed, randBackSeed, duplicateSeed,
						localTieSeeds, primaryFitnessSeeds,
						secondaryFitnessSeeds);
	}
	
}
